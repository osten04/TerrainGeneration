// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

uniform float3 u_offset;

struct grass_output
{
    float3 position;
    float2 facing;
    float  height;
    float  width;
    uint   hash;
};

struct tile
{
    float3 position;
    float  size;
};

StructuredBuffer< tile > input;

RWStructuredBuffer< grass_output > Result;

//RWBuffer< uint > count;

#define lane_size 32

int hash;

uint rand()
{
    // Xorshift algorithm from George Marsaglia's paper
    hash ^= ( hash << 13 );
    hash ^= ( hash >> 17 );
    hash ^= ( hash << 5 );
    return hash;
}

[ numthreads( lane_size, lane_size, 1 ) ]
void CSMain ( uint2 id : SV_DispatchThreadID )
{
    
    grass_output o;
    
    uint index = id.x + id.y * lane_size;
    
    float2 tile_pos = float2( input[0].position.xz ) + u_offset.xz;
    hash = uint(tile_pos.x) * uint(tile_pos.y) + index;
    
    float2 local = float2( uint2( rand() % 100, rand() % 100 ) ) * 0.01f;
    
    o.position   = float3( local.x, 0.0f, local.y ) * input[ 0 ].size + input[ 0 ].position;
    o.facing     = float2( uint2( rand() % 100, rand() % 100 ) ) * 0.02f - float2( 1.0f, 1.0f );
    o.position.y = 0.0f;
    o.width      = float( rand() % 20  ) * 0.0025f + 0.05f;
    o.height     = float( rand() % 100 ) * 0.005f + 0.3f;
    o.hash       = hash;
    
    Result[ index ] = o;
    
    //if ( o.height < 0.01f )
    //{
    //    InterlockedAdd( count[ 0 ], 1 );
        
    //}
}

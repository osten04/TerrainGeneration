// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

uniform float3 u_offset;
uniform float  u_height;

struct grass_output
{
    float3 position;
    float2 facing;
    float  height;
    float  width;
    uint   hash;
    float  tilt;
};

struct tile
{
    float3 position;
    float  size;
};

StructuredBuffer< tile > input;

RWStructuredBuffer< grass_output > Result;

//RWBuffer< uint > count;

#define lane_size 32

uint hash;

uint rand()
{
    // Xorshift algorithm from George Marsaglia's paper
    hash ^= ( hash << 13 );
    hash ^= ( hash >> 17 );
    hash ^= ( hash << 5 );
    return hash;
}

#include "HeightMap.cginc"

[ numthreads( lane_size, lane_size, 1 ) ]
void CSMain ( uint3 lane_id : SV_DispatchThreadID )
{
    grass_output o;
    
    uint2 id = lane_id.xy;
    
    uint index = id.x + id.y * lane_size;
    
    float2 pos = input[0].position.xz + u_offset.xz;
    //hash = ( uint( pos.x ) ) * ( uint( pos.y ) );
    hash = ( uint( pos.x ) ) * ( uint( pos.y ) ) + index;
    //float2 pos = input[0].position.xz + u_offset.xz;
    
    
    float2 local = float2( uint2( rand() % 100, rand() % 100 ) ) * 0.01f;
    
    o.position   = float3( local.x, 0.0f, local.y ) * input[ 0 ].size + float3( input[ 0 ].position.x, 0.0f, input[ 0 ].position.y );
    o.position.y = GetHeight( ( o.position.xz + u_offset.xz ) * 0.02f ) * u_height;
    o.facing     = normalize( float2( uint2( rand() % 100, rand() % 100 ) ) * 0.02f - float2( 1.0f, 1.0f ) );
    o.width      = float( rand() % 20  ) * 0.0025f + 0.05f;
    o.height     = float( rand() % 100 ) * 0.005f + 0.3f;
    o.tilt       = ( float( rand() % 100 ) * 0.02f + 0.5f ) * 0.2f;
    o.hash       = hash;
    
    Result[ index ] = o;
    
    //if ( o.height < 0.01f )
    //{
    //    InterlockedAdd( count[ 0 ], 1 );
        
    //}
}

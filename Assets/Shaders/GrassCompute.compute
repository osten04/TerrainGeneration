// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

uniform float3 u_offset;
uniform float  u_height;

struct grass_output
{
    float3 position;
    float2 facing;
    float  height;
    float  width;
    uint   hash;
    float  tilt;
};

struct tile
{
    float3 position;
    float  size;
};

StructuredBuffer< tile > input;

RWStructuredBuffer< grass_output > Result;

//RWBuffer< uint > count;

#define lane_size 32

uint hash;

uint rand()
{
    // Xorshift algorithm from George Marsaglia's paper
    hash ^= ( hash << 13 );
    hash ^= ( hash >> 17 );
    hash ^= ( hash << 5 );
    return hash;
}

#include "HeightMap.cginc"

[ numthreads( lane_size, lane_size, 1 ) ]
void CSMain ( uint3 lane_id : SV_DispatchThreadID )
{
    grass_output o;
    
    uint2 id = lane_id.xy;
    
    uint index = id.x + id.y * lane_size;
    
    float2 pos = input[0].position.xz + u_offset.xz;
    hash = ( uint( pos.x ) * 100.0f ) * ( uint( pos.y ) * 100.0f ) + index;
    
    
    float2 local = float2( uint2( rand() % 100, rand() % 100 ) ) * 0.01f;
    
    o.position   = float3( local.x, 0.0f, local.y ) * input[ 0 ].size + float3( input[ 0 ].position.x, 0.0f, input[ 0 ].position.z );
    o.position.y = GetHeight( ( o.position.xz + u_offset.xz ) * 0.02f ) * u_height;
    o.facing     = normalize( float2( uint2( rand() % 100, rand() % 100 ) ) * 0.02f - float2( 1.0f, 1.0f ) );
    o.width      = ( float( rand() % 20  ) * 0.0025f + 0.05f ) * 1.5f;
    o.height     = ( float( rand() % 100 ) * 0.005f + 0.3f ) * 1.5f;
    o.tilt       = ( float( rand() % 100 ) * 0.02f + 0.5f ) * 0.2f;
    o.hash       = hash;
    
    Result[ index ] = o;
}
